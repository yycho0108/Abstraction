<!DOCTYPE HTML>
<HTML>
<META HTTP-EQUIV="content-type" content="text/html charset=utf-8">
<HEAD>
    <SCRIPT type = "text/javascript" src="gl-matrix.min.js"></SCRIPT>
    <SCRIPT type = "vShader" id="perVert_vShader">
        attribute vec3 vPos;
        attribute vec2 texCoord;
        attribute vec3 vNormal;

        varying highp vec2 tCoord;
        varying highp vec3 vLight;

        uniform mat4 vMat;
        uniform mat4 mMat;
        uniform mat4 pMat;

        uniform mat4 xFormMat;
        uniform vec3 dirLightDir;
        uniform vec3 dirLightCol;
        uniform vec3 ambLightCol;
        uniform vec3 ptLightPos;
        uniform vec3 ptLightCol;

        void main(void){

        vec4 mvPos = vMat*mMat*vec4(vPos,1.0);

        gl_Position = pMat*mvPos;

        tCoord = texCoord;
        vec4 xFormNorm = xFormMat * vec4(vNormal,1.0);
        vec3 ptLightDir = normalize(ptLightPos - mvPos.xyz);
        vLight = ambLightCol + dirLightCol*max(dot(xFormNorm.xyz, dirLightDir),0.0) + ptLightCol*max(dot(xFormNorm.xyz,ptLightDir),0.0);
        }

    </SCRIPT>
    <SCRIPT type = "fShader" id="perVert_fShader">
        precision mediump float;

        varying highp vec2 tCoord;
        varying highp vec3 vLight;

        uniform sampler2D texSrc;
        uniform bool useTexture;

        void main(void){
        mediump vec4 texelColor;
        if(useTexture){
            texelColor = texture2D(texSrc,tCoord);
            }
         else{
            texelColor = vec4(1.0,1.0,1.0,1.0);
            }
        gl_FragColor = vec4(vLight*texelColor.rgb,texelColor.a*0.9);
        }
    </SCRIPT>
    <SCRIPT type = "vShader" id="perFrag_vShader">
        attribute vec3 vPos;
        attribute vec2 texCoord;
        attribute vec3 vNormal;

        varying highp vec2 tCoord;
        varying highp vec4 mvPos;
        varying highp vec4 xFormNorm;
        varying highp vec4 vP;
        varying highp vec4 ptLightPosV;

        uniform mat4 vMat;
        uniform mat4 mMat;
        uniform mat4 pMat;
        uniform vec3 ptLightPos;
        uniform mat4 xFormMat;


        void main(void){
        mvPos = vMat*mMat*vec4(vPos,1.0);
        gl_Position = pMat*mvPos;
        ptLightPosV = vMat*mMat*vec4(ptLightPos,1.0);

        tCoord = texCoord;
        xFormNorm = xFormMat * vec4(vNormal,1.0);
        }

    </SCRIPT>
    <SCRIPT type = "fShader" id="perFrag_fShader">
        precision mediump float;

        varying highp vec2 tCoord;
        varying highp vec4 mvPos;
        varying highp vec4 xFormNorm;
        varying highp vec4 ptLightPosV;

        uniform vec3 dirLightDir;
        uniform vec3 dirLightCol;
        uniform vec3 ambLightCol;

        uniform vec3 ptLightCol;
        uniform sampler2D texSrc;
        uniform sampler2D specSrc;

        uniform float shiny;
        uniform bool useTexture;


        void main(void){

        mediump vec4 texelColor;
        mediump vec4 specColor;
        if(useTexture){
            texelColor = texture2D(texSrc,tCoord);
            specColor = texture2D(specSrc,tCoord);
            }
         else{
            texelColor = vec4(1.0,1.0,1.0,1.0);
            specColor = vec4(1.0,1.0,1.0,1.0);
            }

        specColor = texture2D(specSrc,tCoord);

        vec3 ptLightDir = normalize(ptLightPosV.xyz - mvPos.xyz);
        vec3 norm = normalize(xFormNorm.xyz);
        vec3 refLightDir = reflect(-ptLightDir,norm);

        float dirLightWeight = max(dot(norm, dirLightDir),0.0);
        float specLightWeight = pow(max(dot(refLightDir, normalize(-mvPos.xyz)), 0.0),shiny*(255.0 -specColor.r*255.0));
        float ptLightWeight = max(dot(norm,ptLightDir),0.0);
        float diffuseLightWeight = max(dot(norm, ptLightDir), 0.0);

        vec3 vLight = ambLightCol + dirLightCol*dirLightWeight + ptLightCol*specLightWeight + ptLightCol*diffuseLightWeight;


        gl_FragColor = vec4(vLight*texelColor.rgb.rgb,texelColor.a*0.9);

        }
    </SCRIPT>
    <SCRIPT type="text/javascript" src="WebglCommon.js"></SCRIPT>
    <SCRIPT type="text/javascript" src="Orientation.js"></SCRIPT>
    <SCRIPT type="text/javascript" src="dataObj.js"></SCRIPT>
    <SCRIPT type="text/javascript" src="Light.js"></SCRIPT>
    <SCRIPT type="text/javascript" src="Camera.js"></SCRIPT>
    <SCRIPT type="text/javascript" src="Texture.js"></SCRIPT>
    <SCRIPT type="text/javascript" src="Surface.js"></SCRIPT>
    <SCRIPT type="text/javascript" src="Scene.js"></SCRIPT>
    <SCRIPT type="text/javascript" src="Entity.js"></SCRIPT>

    <SCRIPT type="text/javascript">
        var scene;
        var shader_1;
        var shader_2;

        function webGLStart(){
            var gl = initGL(document.getElementById("myCanvas"));
            shader_1 = getProgram(gl,["perVert_vShader", "perVert_fShader"]);
            shader_2 = getProgram(gl,["perFrag_vShader", "perFrag_fShader"]);

            gl.useProgram(shader_1);

            scene = new Scene(gl);
            scene.setProgram(gl,shader_1);

           // loadBox(shader_1);
            //loadWorld(shader_1);
            loadBall(shader_1);
            loadTeapot(shader_1);
            var camera = new Camera();
            camera.orientation.offsetPos(0.0,0.0,8.0);
            camera.setProgram(gl,shader_1);
            scene.set("camera",camera);

            var dirLight = new Light("dir");
            dirLight.setProgram(gl, shader_1);
            dirLight.set("dirLightDir",[0.22,0.6,1.0]); //example of modification, though currently auto-update
            dirLight.set("dirLightCol",[0.3,1.0,0.5]);


            var ambLight = new Light("amb");
            ambLight.setProgram(gl,shader_1);
            ambLight.set("ambLightCol", [0.2,0.2,0.2]);

            var ptLight = new Light("pt");
            ptLight.setProgram(gl,shader_1);
            ptLight.set("ptLightPos", [0.0,0.0,0.0]);
            ptLight.set("ptLightCol", [0.3,0.3,0.3]);

            scene.push("light",dirLight);
            scene.push("light",ambLight);
            scene.push("light",ptLight);


            scene.run();

        }
        //user input
        var dragView = false;
        var prevX;
        var prevY;
        function objFromPt(x,y){
            return scene.obj[0];
        }
        function onMouseUp(ev){
            dragView = false;
        }
        function onMouseDown(ev){
            dragView = true;
            prevX = ev.clientX;
            prevY = ev.clientY;
        }
        function onMouseMove(ev){
            if(scene.camera !== undefined && dragView){
                var curX = ev.clientX;
                var curY = ev.clientY;

                var o = scene.camera.orientation;

                o.offsetRot( (curY-prevY)/gl.viewportHeight*scene.camera.fov,
                        (curX-prevX)/gl.viewportHeight*scene.camera.fov,
                        0)
                prevX = curX;
                prevY = curY;
            }
        }
        var isKeyDown = {};
        var LEFT = 37;
        var UP = 38;
        var RIGHT = 39;
        var DOWN = 40;
        var PGUP = 33;
        var PGDN = 34;
        function onKeyDown(ev){
            isKeyDown[ev.keyCode] = true;
           ev.preventDefault();
        }
        function onKeyUp(ev){
            isKeyDown[ev.keyCode] = false;
        }
        function onMouseWheel(ev){
            var zoom = -ev.wheelDelta/100;
            ev.preventDefault();
            var o =scene.camera.orientation;
            o.offsetPos(Math.sin(degToRad(o.rot.y))*zoom,0,Math.cos(degToRad(o.rot.y))*zoom);
        }
        function loadWorld(shaderProgram) {
            var request = new XMLHttpRequest();
            request.open("GET", "world.txt");
            request.onreadystatechange = function() {
                if (request.readyState == 4) {
                    parseWorld(request.responseText,shaderProgram);
                }
            };
            request.send();
        }

        function parseWorld(data,shaderProgram){
            var lines = data.split("\n");
            var vertexCount = 0;
            var vertices = [];
            var texCoord = [];
            var faces = [];
            var vNormal = [];
            var index = 0;
            var triangle = [];
            for (var i in lines) {
                var vals = lines[i].replace(/^\s+/, "").split(/\s+/);
                if (vals.length == 5 && vals[0] != "//") {
                    // It is a line describing a vertex; get X, Y and Z first

                    triangle.push(parseFloat(vals[0]));
                    triangle.push(parseFloat(vals[1]));
                    triangle.push(parseFloat(vals[2]));
                    faces.push(index++); //one vertex.
                    // And then the texture coords
                    texCoord.push(parseFloat(vals[3]));
                    texCoord.push(parseFloat(vals[4]));

                    if(triangle.length >= 9){ // = full triangle
                        vertices = vertices.concat(triangle);
                        //three vertices...
                        var v1 = vec3.create([triangle[0],triangle[1],triangle[2]]);
                        var v2 = vec3.create([triangle[3],triangle[4],triangle[5]]);
                        var v3 =vec3.create([triangle[6],triangle[7],triangle[8]]);
                        triangle = [];
                        var v21 = vec3.create();
                        vec3.subtract(v2,v1,v21);
                        var v32 = vec3.create();
                        vec3.subtract(v3,v2,v32);
                        var vN = vec3.cross(v21,v32);

                        for(var j=0;j<3;++j){
                            vNormal = vNormal.concat(vN);
                        }


                    }
                    vertexCount += 1;
                }
            }

            var dataObjs = {
                vPos: dataObj("vPos", new Float32Array(vertices), gl.ARRAY_BUFFER, vertexCount, 3),
                texCoord: dataObj("texCoord", new Float32Array(texCoord), gl.ARRAY_BUFFER, vertexCount, 2),
                vNormal: dataObj("vNormal", new Float32Array(vNormal),gl.ARRAY_BUFFER, vertexCount, 3),
                faces: dataObj("faces", new Uint16Array(faces),gl.ELEMENT_ARRAY_BUFFER,vertexCount/9, 3)
            };

            var surface = new Surface(shaderProgram,dataObjs);
            var texture = new Texture(shaderProgram,"texSrc","image","firefox.png");//change later
            var world = new Entity(shaderProgram,surface,texture);
            scene.push("obj",world);
        }
        function loadTeapot(shaderProgram) {
            var request = new XMLHttpRequest();
            request.open("GET", "Teapot.json");
            request.onreadystatechange = function() {
                if (request.readyState == 4) {
                    parseTeapot(JSON.parse(request.responseText),shaderProgram);
                }
            }
            request.send();
        }
        function parseTeapot(data,shaderProgram){
            var ptCount = data.vPos.length;
            var dataObjs = {
                vPos: dataObj("vPos", new Float32Array(data.vPos),gl.ARRAY_BUFFER,ptCount,3),
                texCoord: dataObj("texCoord", new Float32Array(data.texCoord), gl.ARRAY_BUFFER, ptCount, 2),
                vNormal: dataObj("vNormal", new Float32Array(data.vNormal),gl.ARRAY_BUFFER, ptCount, 3),
                faces: dataObj("faces", new Uint16Array(data.faces),gl.ELEMENT_ARRAY_BUFFER,ptCount/3, 3)
            };
            var surface = new Surface(shaderProgram,dataObjs);
            var texture = new Texture(shaderProgram,"texSrc","image","metalSurf.jpg");
            var teapot = new Entity(shaderProgram,surface,texture);
            scene.push("obj",teapot);
        }
        function loadBox(shaderProgram){
            var vertices = [
                // Front face
                -1.0, -1.0,  1.0,
                1.0, -1.0,  1.0,
                1.0,  1.0,  1.0,
                -1.0,  1.0,  1.0,

                // Back face
                -1.0, -1.0, -1.0,
                -1.0,  1.0, -1.0,
                1.0,  1.0, -1.0,
                1.0, -1.0, -1.0,

                // Top face
                -1.0,  1.0, -1.0,
                -1.0,  1.0,  1.0,
                1.0,  1.0,  1.0,
                1.0,  1.0, -1.0,

                // Bottom face
                -1.0, -1.0, -1.0,
                1.0, -1.0, -1.0,
                1.0, -1.0,  1.0,
                -1.0, -1.0,  1.0,

                // Right face
                1.0, -1.0, -1.0,
                1.0,  1.0, -1.0,
                1.0,  1.0,  1.0,
                1.0, -1.0,  1.0,

                // Left face
                -1.0, -1.0, -1.0,
                -1.0, -1.0,  1.0,
                -1.0,  1.0,  1.0,
                -1.0,  1.0, -1.0
            ];
            var faces = [
                0,  1,  2,      0,  2,  3,    // front
                4,  5,  6,      4,  6,  7,    // back
                8,  9,  10,     8,  10, 11,   // top
                12, 13, 14,     12, 14, 15,   // bottom
                16, 17, 18,     16, 18, 19,   // right
                20, 21, 22,     20, 22, 23    // left
            ];
            var texCoord = [
                // Front
                0.0,  0.0,
                1.0,  0.0,
                1.0,  1.0,
                0.0,  1.0,
                // Back
                0.0,  0.0,
                1.0,  0.0,
                1.0,  1.0,
                0.0,  1.0,
                // Top
                0.0,  0.0,
                1.0,  0.0,
                1.0,  1.0,
                0.0,  1.0,
                // Bottom
                0.0,  0.0,
                1.0,  0.0,
                1.0,  1.0,
                0.0,  1.0,
                // Right
                0.0,  0.0,
                1.0,  0.0,
                1.0,  1.0,
                0.0,  1.0,
                // Left
                0.0,  0.0,
                1.0,  0.0,
                1.0,  1.0,
                0.0,  1.0
            ];
            var vNormal = [
                //front
                0.0,  0.0,  1.0,
                0.0,  0.0,  1.0,
                0.0,  0.0,  1.0,
                0.0,  0.0,  1.0,

                // back
                0.0,  0.0, -1.0,
                0.0,  0.0, -1.0,
                0.0,  0.0, -1.0,
                0.0,  0.0, -1.0,

                // up
                0.0,  1.0,  0.0,
                0.0,  1.0,  0.0,
                0.0,  1.0,  0.0,
                0.0,  1.0,  0.0,

                // bottom
                0.0, -1.0,  0.0,
                0.0, -1.0,  0.0,
                0.0, -1.0,  0.0,
                0.0, -1.0,  0.0,

                // right
                1.0,  0.0,  0.0,
                1.0,  0.0,  0.0,
                1.0,  0.0,  0.0,
                1.0,  0.0,  0.0,
                // left
                -1.0,  0.0,  0.0,
                -1.0,  0.0,  0.0,
                -1.0,  0.0,  0.0,
                -1.0,  0.0,  0.0
            ];

            var dataObjs = {
                vPos: dataObj("vPos", new Float32Array(vertices), gl.ARRAY_BUFFER, 24, 3),
                texCoord: dataObj("texCoord", new Float32Array(texCoord), gl.ARRAY_BUFFER, 24, 2),
                vNormal: dataObj("vNormal", new Float32Array(vNormal),gl.ARRAY_BUFFER, 24, 3),
                faces: dataObj("faces", new Uint16Array(faces), gl.ELEMENT_ARRAY_BUFFER, 12, 3)
            };

            var surface = new Surface(shaderProgram,dataObjs);
            var texture = new Texture(shaderProgram,"texSrc","image","firefox2.png");//change later
            var f_box = new Entity(shaderProgram,surface,texture);
            f_box.orientation.setPos(0,0,0);
            scene.push("obj",f_box);
        }
        function loadBall(shaderProgram){
            var latitudeBands = 12;
            var longitudeBands = 12;
            var radius = 1.0;

            var vPos = [];
            var vNormal = [];
            var texCoord = [];

            for (var latNumber = 0; latNumber <= latitudeBands; latNumber++) {
                var theta = latNumber * Math.PI / latitudeBands;
                var sinTheta = Math.sin(theta);
                var cosTheta = Math.cos(theta);

                for (var longNumber = 0; longNumber <= longitudeBands; longNumber++) {
                    var phi = longNumber * 2 * Math.PI / longitudeBands;
                    var sinPhi = Math.sin(phi);
                    var cosPhi = Math.cos(phi);

                    var x = cosPhi * sinTheta;
                    var y = cosTheta;
                    var z = sinPhi * sinTheta;
                    var u = 1 - (longNumber / longitudeBands);
                    var v = 1 - (latNumber / latitudeBands);

                    vNormal.push(x);
                    vNormal.push(y);
                    vNormal.push(z);
                    texCoord.push(u);
                    texCoord.push(v);
                    vPos.push(radius * x);
                    vPos.push(radius * y);
                    vPos.push(radius * z);
                }
            }
            var faces = [];

            for (var latNumber = 0; latNumber < latitudeBands; latNumber++) {
                for (var longNumber = 0; longNumber < longitudeBands; longNumber++) {
                    var first = (latNumber * (longitudeBands + 1)) + longNumber;
                    var second = first + longitudeBands + 1;
                    faces.push(first);
                    faces.push(second);
                    faces.push(first + 1);

                    faces.push(second);
                    faces.push(second + 1);
                    faces.push(first + 1);
                }
            }

            var numVert = latitudeBands*longitudeBands;
            var dataObjs = {
                vPos: dataObj("vPos", new Float32Array(vPos), gl.ARRAY_BUFFER, numVert, 3),
                texCoord: dataObj("texCoord", new Float32Array(texCoord), gl.ARRAY_BUFFER, numVert, 2),
                vNormal: dataObj("vNormal", new Float32Array(vNormal),gl.ARRAY_BUFFER, numVert, 3),
                faces: dataObj("faces", new Uint16Array(faces), gl.ELEMENT_ARRAY_BUFFER, numVert*2, 3)
            };

            var surface = new Surface(shaderProgram,dataObjs);
            var texture = new Texture(shaderProgram,"texSrc","image","Earth3.jpg");//change later
           // var specular = new Texture(shaderProgram,"specSrc","image","Earth4.jpg");
            var ball = new Entity(shaderProgram,surface,texture)
            scene.push("obj",ball);
        }

    </SCRIPT>
    </HEAD>
<BODY onload="webGLStart()">
<CANVAS id="myCanvas" tabindex="0" width="1000" height="1000" onmouseup="onMouseUp(event)"
        onmousedown="onMouseDown(event)" onmousemove="onMouseMove(event)"
        onkeydown="onKeyDown(event)" onkeyup="onKeyUp(event)" onmousewheel="onMouseWheel(event)"></CANVAS>

<input type="checkbox" id="perFrag" checked /> Per-fragment lighting<br/>
<input type="checkbox" id="useTexture" checked /> Use Texture<br/>
<table>
    <tr>
        <td>Directional Light Dir</td>
        <td>X :<TEXTAREA id="dirLightX">0.2</TEXTAREA> </td>
        <td>Y :<TEXTAREA id="dirLightY">0.2</TEXTAREA> </td>
        <td>Z :<TEXTAREA id="dirLightZ">0.2</TEXTAREA> </td>
    </tr>
    <tr>
        <td>Directional Light Col</td>
        <td>R :<TEXTAREA id="dirLightR">0.2</TEXTAREA> </td>
        <td>G :<TEXTAREA id="dirLightG">0.2</TEXTAREA> </td>
        <td>B :<TEXTAREA id="dirLightB">0.2</TEXTAREA> </td>
    </tr>
    <tr>
        <td>Point Light Pos</td>
        <td>X :<TEXTAREA id="ptLightX">0.0</TEXTAREA> </td>
        <td>Y :<TEXTAREA id="ptLightY">0.0</TEXTAREA> </td>
        <td>Z :<TEXTAREA id="ptLightZ">0.0</TEXTAREA> </td>
    </tr>
    <tr>
        <td>Point Light Col</td>
        <td>R :<TEXTAREA id="ptLightR">0.0</TEXTAREA> </td>
        <td>G :<TEXTAREA id="ptLightG">0.0</TEXTAREA> </td>
        <td>B :<TEXTAREA id="ptLightB">0.0</TEXTAREA> </td>
    </tr>
    <tr>
        <td>Ambient Light Col</td>
        <td>X :<TEXTAREA id="ambLightR">0.0</TEXTAREA> </td>
        <td>Y :<TEXTAREA id="ambLightG">0.0</TEXTAREA> </td>
        <td>Z :<TEXTAREA id="ambLightB">0.0</TEXTAREA> </td>
    </tr>
    <tr>
        <td>Material Shininess</td>
        <td><TEXTAREA id="shiny">0.3</TEXTAREA></td>
    </tr>
</table>

</BODY>
</HTML>